package com.opencn.mesh;import com.alipay.sofa.ark.api.ArkClient;import com.alipay.sofa.ark.api.ClientResponse;import com.alipay.sofa.ark.common.util.FileUtils;import com.ctrip.framework.apollo.Config;import com.ctrip.framework.apollo.enums.PropertyChangeType;import com.ctrip.framework.apollo.model.ConfigChange;import com.ctrip.framework.apollo.model.ConfigChangeEvent;import com.ctrip.framework.apollo.openapi.client.ApolloOpenApiClient;import com.ctrip.framework.apollo.openapi.dto.NamespaceReleaseDTO;import com.ctrip.framework.apollo.openapi.dto.OpenItemDTO;import com.ctrip.framework.apollo.spring.annotation.ApolloConfig;import com.ctrip.framework.apollo.spring.annotation.ApolloConfigChangeListener;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.opencn.mesh.log.PipelineLogger;import com.opencn.mesh.util.AddressUtils;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.CommandLineRunner;import org.springframework.core.Ordered;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import javax.annotation.Resource;import java.io.File;import java.net.Inet4Address;import java.net.URL;import java.util.List;import java.util.Map;import java.util.Optional;@Componentpublic class ScheduleConfigListener implements CommandLineRunner, Ordered {    private static final Gson G = new GsonBuilder().setDateFormat("yyyy-MM-dd HH:mm:ss").create();    @ApolloConfig("pipeline-instance.json")    private Config instanceConfig;    @Resource    private PipelineApolloEnvConfig envConfig;    @Resource    private ApolloOpenApiClient client;    @Value("${server.port}")    private String port;    @ApolloConfigChangeListener(value = {"pipeline-instance.json"})    public void onChange(ConfigChangeEvent changeEvent) {        for(String key: changeEvent.changedKeys()) {            ConfigChange change = changeEvent.getChange(key);            if(key.equals("content") && PropertyChangeType.MODIFIED.equals(change.getChangeType())) {                String oldValue = change.getOldValue();                String newValue = change.getNewValue();                try {                    PipelineInstanceConfig oldInstanceConfig = G.fromJson(oldValue, PipelineInstanceConfig.class);                    PipelineInstanceConfig newInstanceConfig = G.fromJson(newValue, PipelineInstanceConfig.class);                } catch (Exception e) {                    PipelineLogger.error("[pipeline] instance change  parse failed cause {}", e.getMessage());                }            }        }    }    @Override    public void run(String... args) throws Exception {            Optional<Inet4Address> localIp4Address = AddressUtils.getLocalIp4Address();            if (localIp4Address.isPresent()) {                String instanceName = localIp4Address.get().getHostAddress().concat("@").concat(port);                String instancesStr = instanceConfig.getProperty("content", null);                if (StringUtils.hasText(instancesStr)) {                    PipelineInstanceConfig pipelineInstanceConfig = G.fromJson(instancesStr, PipelineInstanceConfig.class);                    Map<String ,PipelineInstanceConfig.InstanceConfig> instances = pipelineInstanceConfig.getInstances();                    instances.forEach((name, instance) -> {                        if (name.equals(instanceName)) {                            // restart: reload plugin                            if (instance.isRestart()) {                                List<PipelineInstanceConfig.PluginConfig> plugins = instance.getPlugins();                                plugins.forEach(pluginConfig -> {                                    PipelineLogger.debug("[ScheduleConfig] load plugin {} in instance {}", pluginConfig.getName()+":"+pluginConfig.getVersion(), instanceName);                                    operateBiz(pluginConfig.getName(), pluginConfig.getVersion(), pluginConfig.getRepo());                                });                            } else {                                instance.setRestart(true);                                OpenItemDTO item = client.getItem(envConfig.getAppId(), envConfig.getEnv(), "default", "pipeline-instance.json", "content");                                item.setValue(G.toJson(pipelineInstanceConfig));                                client.updateItem(envConfig.getAppId(), envConfig.getEnv(), "default","pipeline-instance.json", item);                                NamespaceReleaseDTO namespaceReleaseDTO = new NamespaceReleaseDTO();                                namespaceReleaseDTO.setReleasedBy("jhon.ye");                                namespaceReleaseDTO.setEmergencyPublish(false);                                namespaceReleaseDTO.setReleaseTitle("test");                                client.publishNamespace(envConfig.getAppId(), envConfig.getEnv(), "default","pipeline-instance.json", namespaceReleaseDTO);                            }                        }                    });                }            }    }    private ClientResponse operateBiz(String bizName, String bizVersion, String repo) {        try {            URL url = new URL(repo);            File bizFile = ArkClient.createBizSaveFile(bizName, bizVersion);            FileUtils.copyInputStreamToFile(url.openStream(), bizFile);            return ArkClient.installBiz(bizFile);        } catch (Throwable e) {            PipelineLogger.error("[pipeline] start plugin  {} failed cause {}",                    bizName+ ":" + bizVersion, e.getMessage());        }        return null;    }    @Override    public int getOrder() {        return Integer.MIN_VALUE + 1;    }}