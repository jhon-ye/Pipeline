package com.opencn.mesh;import com.alipay.sofa.ark.api.ArkClient;import com.alipay.sofa.ark.api.ClientResponse;import com.alipay.sofa.ark.common.util.FileUtils;import com.ctrip.framework.apollo.Config;import com.ctrip.framework.apollo.enums.PropertyChangeType;import com.ctrip.framework.apollo.model.ConfigChange;import com.ctrip.framework.apollo.model.ConfigChangeEvent;import com.ctrip.framework.apollo.openapi.client.ApolloOpenApiClient;import com.ctrip.framework.apollo.openapi.dto.NamespaceReleaseDTO;import com.ctrip.framework.apollo.openapi.dto.OpenItemDTO;import com.ctrip.framework.apollo.spring.annotation.ApolloConfig;import com.ctrip.framework.apollo.spring.annotation.ApolloConfigChangeListener;import com.google.gson.Gson;import com.google.gson.GsonBuilder;import com.google.gson.JsonSyntaxException;import com.opencn.mesh.log.PipelineLogger;import com.opencn.mesh.util.AddressUtils;import com.opencn.mesh.util.ListUtils;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.CommandLineRunner;import org.springframework.core.Ordered;import org.springframework.stereotype.Component;import org.springframework.util.ObjectUtils;import org.springframework.util.StringUtils;import javax.annotation.Resource;import java.io.File;import java.net.URL;import java.util.Arrays;import java.util.List;import java.util.Map;import java.util.Optional;import java.util.concurrent.ExecutorService;@Componentpublic class ScheduleConfigListener implements CommandLineRunner, Ordered {    private static final Gson G = new GsonBuilder().setDateFormat("yyyy-MM-dd HH:mm:ss").setPrettyPrinting().create();    @ApolloConfig("pipeline-instance.json")    private Config instanceConfig;    @Value("#{'${pipeline.plugin.blacklist}'.split(',')}")    private List<String> blacklist;    @Resource    private PipelineApolloEnvConfig envConfig;    @Resource    private ApolloOpenApiClient client;    @Resource    private ExecutorService pipelineExecutor;    @ApolloConfigChangeListener(value="application.properties",interestedKeyPrefixes = {"pipeline.plugin.blacklist"})    public void blacklistChange(ConfigChangeEvent changeEvent) {        for (String key: changeEvent.changedKeys()) {            ConfigChange change = changeEvent.getChange(key);            if (key.equals("pipeline.plugin.blacklist") && PropertyChangeType.MODIFIED.equals(change.getChangeType())) {                String oldValue = change.getOldValue();                String newValue = change.getNewValue();                List<String> oldBlacklist = Arrays.asList(oldValue.split(","));                List<String> newBlacklist  = Arrays.asList(newValue.split(","));                List<String> intersection = ListUtils.intersectList(oldBlacklist, newBlacklist);                //                List<String> install = ListUtils.subList(oldBlacklist, intersection);                List<String> uninstall = ListUtils.subList(newBlacklist, intersection);                String content = instanceConfig.getProperty("content", null);                if (StringUtils.hasText(content)) {                    PipelineInstanceConfig pipelineInstanceConfig = G.fromJson(content, PipelineInstanceConfig.class);                    String instanceName = null;                    Optional<String> address = AddressUtils.getHostName();                    if (address.isPresent()) {                        instanceName = address.get();                    }                    if (!StringUtils.hasText(instanceName)) {                        PipelineLogger.error("can not get instance identify check it");                        return;                    }                    PipelineInstanceConfig.InstanceConfig instance = pipelineInstanceConfig.getInstances().get(instanceName);                    Map<String, PipelineInstanceConfig.PluginConfig> plugins = instance.getPlugins();                    if (!ObjectUtils.isEmpty(plugins)) {                        // do install                        install.forEach(identify -> {                            if (plugins.containsKey(identify)) {                                PipelineInstanceConfig.PluginConfig plugin = plugins.get(identify);                                asyncOperateBiz(plugin.getName(), plugin.getVersion(), plugin.getRepo(), "INSTALL");                            }                        });                        // do uninstall                        uninstall.forEach(identify ->{                            if (plugins.containsKey(identify)) {                                PipelineInstanceConfig.PluginConfig plugin = plugins.get(identify);                                asyncOperateBiz(plugin.getName(), plugin.getVersion(), plugin.getRepo(), "UNINSTALL");                            }                        });                    }                }            }        }    }    @ApolloConfigChangeListener(value = {"pipeline-instance.json"})    public void onChange(ConfigChangeEvent changeEvent) {        Optional<String> address;        String instanceName = null;        address = AddressUtils.getHostName();        if (address.isPresent()) {            instanceName = address.get();        }        if (!StringUtils.hasText(instanceName)) {            PipelineLogger.error("can not get instance identify check it");            return;        }        for(String key: changeEvent.changedKeys()) {            ConfigChange change = changeEvent.getChange(key);            if(key.equals("content") && PropertyChangeType.MODIFIED.equals(change.getChangeType())) {                String oldValue = change.getOldValue();                String newValue = change.getNewValue();                try {                    PipelineInstanceConfig oldInstanceConfig = G.fromJson(oldValue, PipelineInstanceConfig.class);                    PipelineInstanceConfig newInstanceConfig = G.fromJson(newValue, PipelineInstanceConfig.class);                    PipelineInstanceConfig.InstanceConfig oldInstance = oldInstanceConfig.getInstances().get(instanceName);                    PipelineInstanceConfig.InstanceConfig newInstance = newInstanceConfig.getInstances().get(instanceName);                    // oldInstance = null represent the instance is first running do not care                    if (!ObjectUtils.isEmpty(oldInstance)) {                        Map<String, PipelineInstanceConfig.PluginConfig> oldPlugins = oldInstance.getPlugins();                        Map<String, PipelineInstanceConfig.PluginConfig> newPlugins = newInstance.getPlugins();                        if (!ObjectUtils.isEmpty(newPlugins)) {                            newPlugins.forEach((identify, plugin) -> {                                if (ObjectUtils.isEmpty(oldPlugins) || !oldPlugins.containsKey(identify)) {                                    // install                                    if (ObjectUtils.isEmpty(blacklist) || (!ObjectUtils.isEmpty(blacklist) && !blacklist.contains(identify))) {                                        asyncOperateBiz(plugin.getName(), plugin.getVersion(), plugin.getRepo(), "INSTALL");                                    }//                            operateBiz(plugin.getName(), plugin.getVersion(), plugin.getRepo(), "INSTALL");                                }                            });                        }                        if (!ObjectUtils.isEmpty(oldPlugins)) {                            oldPlugins.forEach((identify, plugin) -> {                                // uninstall the plugin what are in the blacklist                                if (blacklist.contains(identify)) {                                    asyncOperateBiz(plugin.getName(), plugin.getVersion(), plugin.getRepo(), "UNINSTALL");                                }                                if (ObjectUtils.isEmpty(newPlugins) || !newPlugins.containsKey(identify)) {                                    // uninstall                                    asyncOperateBiz(plugin.getName(), plugin.getVersion(), plugin.getRepo(), "UNINSTALL");//                            operateBiz(plugin.getName(), plugin.getVersion(), plugin.getRepo(), "UNINSTALL");                                }                            });                        }                    }                } catch (JsonSyntaxException e) {                    PipelineLogger.error("[ScheduleConfigListener] can not parse pipeline instance config please check json syntax");                    break;                }            }        }    }    private void asyncOperateBiz(String bizName, String bizVersion, String repo, String operateType) {        pipelineExecutor.submit(() -> {            try {                URL url = new URL(repo);                File bizFile = ArkClient.createBizSaveFile(bizName, bizVersion);                FileUtils.copyInputStreamToFile(url.openStream(), bizFile);                switch (operateType) {                    case "INSTALL":                        ArkClient.installBiz(bizFile);                        break;                    case "UNINSTALL":                        ArkClient.uninstallBiz(bizName, bizVersion);                        break;                    default:                }            } catch (Throwable e) {                PipelineLogger.error("[pipeline] start plugin  {} failed cause {}",                        bizName+ ":" + bizVersion, e.getMessage());            }        });    }    @Override    public void run(String... args) {            Optional<String> address = AddressUtils.getHostName();            if (address.isPresent()) {                String instanceName = address.get();                PipelineLogger.info("instance {} staring.....", instanceName);                String instancesStr = instanceConfig.getProperty("content", null);                PipelineInstanceConfig pipelineInstanceConfig;                if (StringUtils.hasText(instancesStr)) {                    pipelineInstanceConfig = G.fromJson(instancesStr, PipelineInstanceConfig.class);                    Map<String ,PipelineInstanceConfig.InstanceConfig> instances = pipelineInstanceConfig.getInstances();                    // reload plugins of myself                    if (instances.containsKey(instanceName)) {                        PipelineInstanceConfig.InstanceConfig instance = instances.get(instanceName);                        Map<String, PipelineInstanceConfig.PluginConfig> plugins = instance.getPlugins();                        if (instance.isRestart() && !ObjectUtils.isEmpty(plugins)) {                            plugins.forEach((identify, plugin) -> {                                PipelineLogger.debug("[ScheduleConfig] load plugin {} in instance {}",identify, instanceName);                                if (ObjectUtils.isEmpty(blacklist) || (!ObjectUtils.isEmpty(blacklist) && !blacklist.contains(identify))) {                                    //asyncOperateBiz(plugin.getName(), plugin.getVersion(), plugin.getRepo(), "INSTALL");                                    operateBiz(plugin.getName(), plugin.getVersion(), plugin.getRepo(), "INSTALL");                                }                            });                            return;                        } else if (!instance.isRestart()) {                            instance.setRestart(true);                        }                    } else {                        // add instance of myself                        instances.put(instanceName, PipelineInstanceConfig.InstanceConfig.builder().restart(true).build());                    }                } else {                    // no  pipeline-instance.json create new                    pipelineInstanceConfig = PipelineInstanceConfig.builder().build();                }                OpenItemDTO item = client.getItem(envConfig.getAppId(), envConfig.getEnv(), envConfig.getCluster(), "pipeline-instance.json", "content");                if (!ObjectUtils.isEmpty(item)) {                    item.setValue(G.toJson(pipelineInstanceConfig));                    client.createOrUpdateItem(envConfig.getAppId(), envConfig.getEnv(), envConfig.getCluster(),"pipeline-instance.json", item);                    NamespaceReleaseDTO namespaceReleaseDTO = new NamespaceReleaseDTO();                    namespaceReleaseDTO.setReleasedBy("jhon.ye");                    namespaceReleaseDTO.setEmergencyPublish(false);                    namespaceReleaseDTO.setReleaseTitle("test");                    client.publishNamespace(envConfig.getAppId(), envConfig.getEnv(), envConfig.getCluster(),"pipeline-instance.json", namespaceReleaseDTO);                }            }    }    private ClientResponse operateBiz(String bizName, String bizVersion, String repo, String operateType) {        try {            URL url = new URL(repo);            File bizFile = ArkClient.createBizSaveFile(bizName, bizVersion);            FileUtils.copyInputStreamToFile(url.openStream(), bizFile);            switch (operateType) {                case "INSTALL":                    return ArkClient.installBiz(bizName, bizVersion, bizFile);//                    return ArkClient.installBiz(bizFile);                case "UNINSTALL":                    return ArkClient.uninstallBiz(bizName, bizVersion);                default:                    return null;            }        } catch (Throwable e) {            PipelineLogger.error("[pipeline] start plugin  {} failed cause {}",                    bizName+ ":" + bizVersion, e.getMessage());        }        return null;    }    @Override    public int getOrder() {        return Integer.MIN_VALUE + 1;    }}